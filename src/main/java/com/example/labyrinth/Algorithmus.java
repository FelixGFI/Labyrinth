package com.example.labyrinth;

import java.util.ArrayList;

public class Algorithmus {
    static int hoehe = 20;
    static int breite = 50;
    static int[][] labyrinth = new int[breite][hoehe];

    static final int EMPTY = 0;
    static final int WALL = 1;
    static final int SIDE_PATH = 2;
    static final int RIGHT_PATH = 3;
    static final int MIDDLE = 4;
    static final int RAND = 5;
    static final int AKT_PATH = 6;
    static Tile aktTile;

    static char direction;

    static final char DIR_LINKS = 'l';
    static final char DIR_RECHTS = 'r';
    static final char DIR_OBEN = 'o';
    static final char DIR_UNTEN = 'u';

    static ArrayList<Tile> allPathTiles = new ArrayList<>();

    public static void main(String[] args) throws Exception {
        for (int i = 0; i < 10; i++) {
            generateLabyrinth();
            printArray();
        }
    }

    private static void generateLabyrinth() throws Exception {
        generateBorder();
        generateStartAndGoal();
        generateInterior();
    }

    private static void generateInterior() throws Exception {
        //initial
        Tile diesesTile = getNextTile(direction);

        setATileOnRightPath(diesesTile);

        //TODO write all paths into an array, wenn die while schleife mehr als x mal durchlaufen wurde (if funktion und counter einfügen) dan solln schritt im array zurück gegangen, und erneut versucht werden

        int failedTrysToGenerateNextTile = 0;

        //unless Borken (by raeching the middle) this loop goes on
        while(true) {
        //direction to potentially set the next tile in is generated by chance
            boolean directionAllright = false;
            char tryDirection = ' ';
            /*while(!directionAllright) {*/
                int directionInt = (int) (Math.random()* 4);
                if(directionInt == 0) {
                    tryDirection = DIR_RECHTS;
                } else if(directionInt == 1) {
                    tryDirection = DIR_OBEN;
                } else if(directionInt == 2) {
                    tryDirection = DIR_LINKS;
                } else if(directionInt == 3) {
                    tryDirection = DIR_UNTEN;
                }
                /*failedTrysToGenerateNextTile++;
                if(tryDirection != getOpositDirection(direction) && tryDirection != ' '){
                    directionAllright = true;
                }
            }*/

            diesesTile = getNextTile(tryDirection);
            int xCord = aktTile.getxCord();
            int yCord = aktTile.getyCord();
            /*if(diesesTile.getTileStatus() == rand || diesesTile.getTileStatus() == rightPath) {
                break;
            }*/



            Tile links         = new Tile(xCord-1, yCord, labyrinth[xCord-1][yCord]);
            Tile oben          = new Tile(xCord, yCord-1, labyrinth[xCord][yCord-1]);
            Tile rechts        = new Tile(xCord+1, yCord, labyrinth[xCord+1][yCord]);
            Tile unten         = new Tile(xCord, yCord+1, labyrinth[xCord][yCord+1]);

            Tile linksOben     = new Tile(xCord-1, yCord-1, labyrinth[xCord-1][yCord-1]);
            Tile rechtsOben    = new Tile(xCord+1, yCord-1, labyrinth[xCord+1][yCord-1]);
            Tile linksUnten    = new Tile(xCord-1, yCord+1, labyrinth[xCord-1][yCord+1]);
            Tile rechtsUnten   = new Tile(xCord+1, yCord+1, labyrinth[xCord+1][yCord+1]);

            Tile linksLinks = null;
            Tile obenOben = null;
            Tile rechtsRechts = null;
            Tile untenUnten = null;
            try {

            } catch (IndexOutOfBoundsException e) {
                linksLinks    = new Tile(xCord-2, yCord, labyrinth[xCord-2][yCord]);
            }
            try {
                obenOben    = new Tile(xCord, yCord-2, labyrinth[xCord][yCord-2]);
            } catch (IndexOutOfBoundsException e) {

            }
            try {
                rechtsRechts    = new Tile(xCord+2, yCord, labyrinth[xCord+2][yCord]);
            } catch (IndexOutOfBoundsException e) {

            }
            try {
                untenUnten    = new Tile(xCord, yCord+2, labyrinth[xCord][yCord+2]);
            } catch (IndexOutOfBoundsException e) {

            }

            boolean tileGoodToBeSet = false;
            if (tryDirection == DIR_RECHTS) {
                if(!isPathOrRand(links) && !isPath(linksOben) && !isPath(linksUnten)) {
                    tileGoodToBeSet = true;
                }
            } else if(tryDirection == DIR_LINKS) {
                if(!isPathOrRand(rechts) && !isPath(rechtsOben) && !isPath(rechtsUnten)) {
                    tileGoodToBeSet = true;
                }
            } else if(tryDirection == DIR_OBEN) {
                if(!isPathOrRand(unten) && !isPath(rechtsUnten) && !isPath(linksUnten)) {
                    tileGoodToBeSet = true;
                }
            } else if(tryDirection == DIR_UNTEN) {
                if(!isPathOrRand(oben) && !isPath(rechtsOben) && !isPath(linksOben)) {
                    tileGoodToBeSet = true;
                }
            }

            failedTrysToGenerateNextTile++;

            if(tileGoodToBeSet) {
                direction = tryDirection;
                setATileOnRightPath(diesesTile);
                failedTrysToGenerateNextTile = 0;
            }


            /*boolean directionUnconfirmed = true;
            char tryDirection = direction;
            while(directionUnconfirmed) {
                int directionDigit = (int) (Math.random() * 3);

                if(direction == 'l') {
                    if(directionDigit == 0) {
                        tryDirection = 'l';
                    } else if(directionDigit == 1) {
                        tryDirection = 'o';
                    } else if(directionDigit == 2) {
                        tryDirection = 'u';
                    }
                } else if(direction == 'r') {
                    if(directionDigit == 0) {
                        tryDirection = 'r';
                    } else if(directionDigit == 1) {
                        tryDirection = 'o';
                    } else if(directionDigit == 2) {
                        tryDirection = 'u';
                    }
                } else if(direction == 'o') {
                    if(directionDigit == 0) {
                        tryDirection = 'r';
                    } else if(directionDigit == 1) {
                        tryDirection = 'l';
                    } else if(directionDigit == 2) {
                        tryDirection = 'o';
                    }
                } else if(direction == 'u') {
                    if(directionDigit == 0) {
                        tryDirection = 'r';
                    } else if(directionDigit == 1) {
                        tryDirection = 'l';
                    } else if(directionDigit == 2) {
                        tryDirection = 'u';
                    }
                }
               //TODO needs rework
                if(tryDirection == 'o') {
                    if(unten.getTileStatus() != rand && unten.getTileStatus() != wall && unten.getTileStatus() != rightPath && unten.getTileStatus()!= sidePath) {
                        directionUnconfirmed = false;
                    } else {
                        if(unten.getTileStatus() == rightPath || unten.getTileStatus() == sidePath) {
                            if((links.getTileStatus() == rand || links.getTileStatus() == wall || links.getTileStatus() == empty) && (rechts.getTileStatus() == rand || rechts.getTileStatus() == wall || rechts.getTileStatus() == empty)) {

                            }
                        }
                    }
                }
                if(tryDirection == 'u') {
                    if(oben.getTileStatus() != rand && oben.getTileStatus() != wall && oben.getTileStatus() != rightPath && oben.getTileStatus()!= sidePath) {
                        directionUnconfirmed = false;
                    } else {
                        if(oben.getTileStatus() == rightPath || oben.getTileStatus() == sidePath) {
                            if((links.getTileStatus() == rand || links.getTileStatus() == wall || links.getTileStatus() == empty) && (rechts.getTileStatus() == rand || rechts.getTileStatus() == wall || rechts.getTileStatus() == empty)) {

                            }
                        }
                    }
                }
                if(tryDirection == 'r') {
                    if(links.getTileStatus() != rand && links.getTileStatus() != wall && links.getTileStatus() != rightPath && links.getTileStatus()!= sidePath) {
                        directionUnconfirmed = false;
                    } else {
                        if(links.getTileStatus() == rightPath || links.getTileStatus() == sidePath) {
                            if((oben.getTileStatus() == rand || oben.getTileStatus() == wall || oben.getTileStatus() == empty) && (unten.getTileStatus() == rand || unten.getTileStatus() == wall || unten.getTileStatus() == empty)) {

                            }
                        }
                    }
                }
                if(tryDirection == 'l') {
                    if(rechts.getTileStatus() != rand && rechts.getTileStatus() != wall && rechts.getTileStatus() != rightPath && rechts.getTileStatus()!= sidePath) {
                        directionUnconfirmed = false;
                    } else {
                        if(rechts.getTileStatus() == rightPath || rechts.getTileStatus() == sidePath) {
                            if((oben.getTileStatus() == rand || oben.getTileStatus() == wall || oben.getTileStatus() == empty) && (unten.getTileStatus() == rand || unten.getTileStatus() == wall || unten.getTileStatus() == empty)) {

                            }
                        }
                    }
                }
            }

            direction = tryDirection;
            */
            if(isNextToMiddle(links, oben, rechts, unten)) {
                break;
            }

            if(failedTrysToGenerateNextTile > 50) {
                labyrinth[aktTile.getxCord()][aktTile.getyCord()] = RIGHT_PATH;

                try{
                    aktTile = allPathTiles.get(allPathTiles.indexOf(aktTile) - 3);
                } catch (Exception e) {
                    aktTile = allPathTiles.get(allPathTiles.indexOf(aktTile) - 1);
                }
                aktTile = allPathTiles.get(allPathTiles.indexOf(aktTile) - 1);
                labyrinth[aktTile.getxCord()][aktTile.getyCord()] = AKT_PATH;
                failedTrysToGenerateNextTile = 0;
            }
        }
    }

    private static boolean isPath(Tile givenTile) {
        if(givenTile == null) {
            return true;
        } else {
            return givenTile.getTileStatus() == RIGHT_PATH || givenTile.getTileStatus() == SIDE_PATH || givenTile.getTileStatus() == AKT_PATH || givenTile.getTileStatus() == MIDDLE;
        }
    }
    private static boolean isPathOrRand(Tile givenTile) {
        if(givenTile == null) {
            return true;
        } else {
            return givenTile.getTileStatus() == RIGHT_PATH || givenTile.getTileStatus() == SIDE_PATH || givenTile.getTileStatus() == AKT_PATH || givenTile.getTileStatus() == MIDDLE || givenTile.getTileStatus() == RAND;
        }
    }

    private static char getOpositDirection(char direction) {
        char opositeDirection = ' ';
        if(direction == DIR_LINKS) {
            opositeDirection = DIR_RECHTS;
        } else if(direction == DIR_RECHTS) {
            opositeDirection = DIR_LINKS;
        } else if(direction == DIR_OBEN) {
            opositeDirection = DIR_UNTEN;
        } else if (direction == DIR_UNTEN) {
            opositeDirection = DIR_OBEN;
        }
        return opositeDirection;
    }

    private static boolean isNextToMiddle(Tile links, Tile oben, Tile rechts, Tile unten) {
        return links.getTileStatus() == MIDDLE || rechts.getTileStatus() == MIDDLE || oben.getTileStatus() == MIDDLE || unten.getTileStatus() == MIDDLE;
    }

    private static Tile getNextTile(char tryDirection) throws Exception {
        Tile nextTile = null;
        if(tryDirection == DIR_LINKS) {
            nextTile = new Tile(aktTile.getxCord() + 1, aktTile.getyCord(), labyrinth[aktTile.getxCord() + 1][aktTile.getyCord()]);
        } else if(tryDirection == DIR_RECHTS) {
            nextTile = new Tile(aktTile.getxCord() - 1, aktTile.getyCord(), labyrinth[aktTile.getxCord() - 1][aktTile.getyCord()]);
        } else if(tryDirection == DIR_OBEN) {
            nextTile = new Tile(aktTile.getxCord(), aktTile.getyCord() + 1, labyrinth[aktTile.getxCord()][aktTile.getyCord() + 1]);
        } else if(tryDirection == DIR_UNTEN) {
            nextTile = new Tile(aktTile.getxCord(), aktTile.getyCord() - 1, labyrinth[aktTile.getxCord()][aktTile.getyCord()-1]);
        } else {

            Exception e = new Exception("generationError! Please try again!");
            throw e;
        }
        return nextTile;
    }

    /*private static void generateLayers() {
        int xstart = 1;
        int ystart = 1;
        int xstop = breite - 2;
        int ystop = hoehe - 2;
        boolean xstartModify = true;
        boolean ystartModify = true;
        boolean xstopModify = true;
        boolean ystopModify = true;

        while(xstartModify || ystartModify || xstartModify || ystopModify) {
            for (int i = xstart; i <= xstop; i++) {
                setTile(i, ystart);
                //labyrinth[i][ystart] = wall;
            }
            for (int i = xstart; i <= xstop; i++) {
                setTile(i, ystop);
                //labyrinth[i][ystop] = wall;
            }
            for (int i = ystart; i <= ystop; i++) {
                setTile(xstart, i);
                //labyrinth[xstart][i] = wall;
            }
            for (int i = ystart; i <= ystop; i++) {
                setTile(xstop, i);
                //labyrinth[xstop][i] = wall;
            }

            if(!((ystop - 1) - (ystart + 1) > 3)) {
                if(labyrinth[breite/2][ystop - 1] == 4) {
                    ystopModify = false;
                }
                if(labyrinth[breite/2][ystart + 1] == 4) {
                    ystartModify = false;
                }
            }
            if(!((xstop - 1) - (xstart + 1) > 3)) {
                if (labyrinth[xstop - 1][hoehe/2] == 4) {
                    xstopModify = false;
                }
                if (labyrinth[xstart + 1][hoehe/2] == 4) {
                    xstartModify = false;
                }
            }
            if(xstartModify) {
                xstart++;
            }
            if(ystartModify) {
                ystart++;
            }
            if(xstopModify) {
                xstop--;
            }
            if(ystopModify) {
                ystop--;
            }

        }
    }*/

    /*private static void setTile(int xCord, int yCord) {
         Tile diesesTile = new Tile(xCord, yCord, labyrinth[xCord][yCord]);
         if(diesesTile.tileStatus == 0) {

             Tile links         = new Tile(xCord-1, yCord, labyrinth[xCord-1][yCord]);
             Tile oben          = new Tile(xCord, yCord-1, labyrinth[xCord][yCord-1]);
             Tile rechts        = new Tile(xCord+1, yCord, labyrinth[xCord+1][yCord]);
             Tile unten         = new Tile(xCord, yCord+1, labyrinth[xCord][yCord+1]);

             Tile linksOben     = new Tile(xCord-1, yCord-1, labyrinth[xCord-1][yCord-1]);
             Tile rechtsOben    = new Tile(xCord+1, yCord-1, labyrinth[xCord+1][yCord-1]);
             Tile linksUnten    = new Tile(xCord-1, yCord+1, labyrinth[xCord-1][yCord+1]);
             Tile rechtsUnten   = new Tile(xCord+1, yCord+1, labyrinth[xCord+1][yCord+1]);

             Tile linksLinks = null;
             Tile obenOben = null;
             Tile rechtsRechts = null;
             Tile untenUnten = null;
             try {

             } catch (IndexOutOfBoundsException e) {
                 linksLinks    = new Tile(xCord-2, yCord, labyrinth[xCord-2][yCord]);
             }
             try {
                 obenOben    = new Tile(xCord, yCord-2, labyrinth[xCord][yCord-2]);
             } catch (IndexOutOfBoundsException e) {

             }
             try {
                 rechtsRechts    = new Tile(xCord+2, yCord, labyrinth[xCord+2][yCord]);
             } catch (IndexOutOfBoundsException e) {

             }
             try {
                 untenUnten    = new Tile(xCord, yCord+2, labyrinth[xCord][yCord+2]);
             } catch (IndexOutOfBoundsException e) {

             }


             if(!(aktTile.equalsThisTile(links) || aktTile.equalsThisTile(rechts) || aktTile.equalsThisTile(oben) || aktTile.equalsThisTile(unten))) {
                 setATileToWall(diesesTile);
             } else {
                 if(aktTile.equalsThisTile(links)) {
                     if(linksLinks == null) {
                         setATileOnRightPath(diesesTile);
                     }
                 } else if(aktTile.equalsThisTile(rechts)) {
                     if(rechtsRechts == null) {
                         setATileOnRightPath(diesesTile);
                     }
                 } else if(aktTile.equalsThisTile(oben)) {
                     if(obenOben == null) {
                         setATileOnRightPath(diesesTile);
                     }
                 } else if(aktTile.equalsThisTile(unten)) {
                    if(untenUnten == null) {
                        setATileOnRightPath(diesesTile);
                     }
                 } else {
                     setATileToWall(diesesTile);
                 }


             }

         }
    }*/

    private static void setATileToWall(Tile diesesTile) {
        diesesTile.setTileStatus(WALL);
        setGivenTileInLabyrinth(diesesTile);
    }

    private static void setATileOnRightPath(Tile diesesTile) {
        aktTile.setTileStatus(RIGHT_PATH);
        diesesTile.setTileStatus(AKT_PATH);
        setGivenTileInLabyrinth(aktTile);
        setGivenTileInLabyrinth(diesesTile);
        aktTile= diesesTile;
        allPathTiles.add(aktTile);
    }

    private static void setGivenTileInLabyrinth (Tile tile){
        labyrinth = tile.setTileInLabyrinth(labyrinth);
    }
    private static void generateStartAndGoal() {
        int xmitte = breite/2;
        int ymitte = hoehe/2;
        labyrinth[xmitte][ymitte] = MIDDLE;
        labyrinth[xmitte + 1][ymitte] = MIDDLE;
        labyrinth[xmitte - 1][ymitte] = MIDDLE;
        labyrinth[xmitte + 1][ymitte + 1] = MIDDLE;
        labyrinth[xmitte - 1][ymitte + 1] = MIDDLE;
        labyrinth[xmitte + 1][ymitte - 1] = MIDDLE;
        labyrinth[xmitte - 1][ymitte - 1] = MIDDLE;
        labyrinth[xmitte][ymitte + 1] = MIDDLE;
        labyrinth[xmitte][ymitte - 1] = MIDDLE;

        int side = (int) (Math.random() * 4);
        int x = -1;
        int y = -1;
        if(side == 0) {
            x = 0;
            direction = DIR_LINKS;
        } else if(side == 1) {
            y = 0;
            direction = DIR_OBEN;
        } else if(side == 2) {
            x = breite - 1;
            direction = DIR_RECHTS;
        } else if(side == 3) {
            y = hoehe - 1;
            direction = DIR_UNTEN;
        }


        if(y == -1) {
            y = (int)( Math.random() * (hoehe - 2)) + 1;
        }
        if(x == -1) {
            x = (int)( Math.random() * (breite - 2)) + 1;
        }
        labyrinth[x][y] = AKT_PATH;
        aktTile = new Tile(x, y, labyrinth[x][y]);


    }

    private static void generateBorder() {
        for(int y = 0; y < hoehe; y++) {
            labyrinth[0][y] = RAND;
            labyrinth[breite-1][y] = RAND;
        }
        for(int x = 0; x < breite; x++) {
            labyrinth[x][0] = RAND;
            labyrinth[x][hoehe-1] = RAND;
        }
    }

    public static void printArray() {
        for(int y = 0; y < hoehe; y++){
            for (int x = 0; x < breite; x++) {
                if(labyrinth[x][y] == WALL) {
                    System.out.print("x");
                } else if (labyrinth[x][y] == SIDE_PATH) {
                    System.out.print("s");
                } else if (labyrinth[x][y] == RIGHT_PATH) {
                    System.out.print("p");
                }else if (labyrinth[x][y] == MIDDLE) {
                    System.out.print("z");
                } else if (labyrinth[x][y] == RAND) {
                    System.out.print("+");
                } else if(labyrinth[x][y] == AKT_PATH) {
                    System.out.print("c");
                } else {
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
    }
}
